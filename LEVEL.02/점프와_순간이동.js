function solution(n){
  let answer = 0;
  while(n > 0){
    if(n%2!==0){
      n--;
      answer++
    }else n /= 2
  }
  return answer;
}

// 로직 설명 )
// 0에서 n에 도달하는 방법을 생각하는 것 보다는 반대로 n에서 0에 도달하는 방법을 생각했다.
// 만약 n이 6일 때, 0 -> 1(뛰기) -> 2(점프) -> 3(뛰기) -> 6(점프)로 생각하는 것보다는
// 6 -> 3(순간이동) -> 2(뛰기) -> 1(순간이동) -> 0(뛰기)로 생각하는 것이 어쨋든 값은 같으니 로직을 이해하기 편하다는 것이다.
// 그 이유는 홀수 짝수와 관련 있다. 
// 순간이동을 하게 되면 무조건 이동한 거리가 짝수가 되며 이전 거리의 x 2가 된다. 
// 반면 그냥 뛰기를 하게 될 경우, + 1이 되기 때문에 홀수가 될수도 있고 짝수가 될 수도 있다.
// 이 규칙을 고려 했을 때, 0 -> N으로 가는 방법을 고려 하게 되면 모든 경우를 탐색해서 최소한의 건전지를 사용하는 방법을 찾아야 한다.
// 하지만 N -> 0으로 가는 방법을 고려 한다면, 짝수 일때는 무조건 순간 이동을 해서 나누기 2를 하고, 홀수 일때는 -1을 하면 되기 때문에 여러 케이스를 탐색할 필요도 없다.
